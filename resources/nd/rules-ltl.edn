; lwb Logic WorkBench -- Natural deduction

; Copyright (c) 2015 - 2016 Tobias VÃ¶lzel, Burkhardt Renz, THM. All rights reserved.
; The use and distribution terms for this software are covered by the
; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php).
; By using this software in any fashion, you are agreeing to be bound by
; the terms of this license.

;; all data regarding forward/backward of the rules are without engagement

; AND
{:id :and-i
 :given      [(at [i] phi) (at [i] psi)]
 :conclusion [(at [i] (and phi psi))]}
{:id :and-e1
 :given      [(at [i] (and phi psi))]
 :conclusion [(at [i] phi)]}
{:id :and-e2
 :given      [(at [i] (and phi psi))]
 :conclusion [(at [i] psi)]}

; OR
{:id :or-i1
 :given      [(at [i] phi)]
 :conclusion [(at [i] (or phi psi))]}
{:id :or-i2
 :given      [(at [i] psi)]
 :conclusion [(at [i] (or phi psi))]}
{:id :or-e
 :given      [(at [i] (or phi psi)) (infer (at [i] phi) (at [i] chi)) (infer (at [i] psi) (at[i] chi))]
 :conclusion [(at [i] chi)]}

; IMPL
{:id :impl-i
 :given      [(infer (at [i] phi) (at [i] psi))]
 :conclusion [(at [i] (impl phi psi))]}
{:id :impl-e
 :given      [(at [i] (impl phi psi)) (at [i] phi)]
 :conclusion [(at [i] psi)]}

; NOT
{:id :not-i
 :given      [(infer (at [j] phi) (at [i] contradiction))]
 :conclusion [(at [j] (not phi))]}
{:id :not-e
 :given      [(at [i] (not phi)) (at [i] phi)]
 :conclusion [(at [j] contradiction)]}

; RAA/EFQ
{:id :raa
 :given      [(infer (at [j] (not phi)) (at [i] contradiction))]
 :conclusion [(at [j] phi)]}
{:id :efq
 :given      [(at [i] contradiction)]
 :conclusion [(at [j] phi)]}

; ATNEXT
{:id :atnext-i
 :given      [(at [j] phi) (succ i j)]
 :conclusion [(at [i] (atnext phi))]}
{:id :atnext-e
 :given      [(at [i] (atnext phi)) (succ i j)]
 :conclusion [(at [j] phi)]}

; ALWAYS
{:id :always-i
 :given      [(infer (<= i j) (at [j] phi))]
 :conclusion [(at [i] (always phi))]}
{:id :always-e 
 :given      [(at [i] (always phi)) (<= i j)]
 :conclusion [(at [j] phi)]}

; FINALLY
{:id :finally-i
 :given      [(at [j] phi) (<= i j)]
 :conclusion [(at [i] (finally phi))]}
{:id :finally-e
 :given      [(at [i] (finally phi))]
 :conclusion [(<= i j) (at [j] phi)]}

; UNTIL
{:id :until-i
 :given      [(at [i] psi)]
 :conclusion [(at [i] (until phi psi))]}
{:id :until-e
 :given      [(at [i] (always (impl psi chi)))
              (at [i] (always (impl (and phi (atnext chi)) chi)))]
 :conclusion [(at [i] (impl (until phi psi) chi))]}
{:id :not-until
 :given      [(at [i] (not (until phi psi)))]
 :conclusion [(at [i] (or (always (not psi))
                          (until (not psi) (and (not phi) (not psi)))))]}

; RELATIONAL JUDGEMENTS
{:id :reflexiv
 :given      []
 :conclusion [(<= i i)]}
{:id :serial
 :given      []
 :conclusion [(succ i j)]}
{:id :</<=
 :given      [(< i j)]
 :conclusion [(<= i j)]}
{:id :atnext/<=
 :given      [(succ i j)]
 :conclusion [(<= i j)]}
{:id :transitiv
 :given      [(<= i j) (<= j k)]
 :conclusion [(<= i k)]}
{:id :linear
 :given      [(<= i j) (<= i k)]
 :conclusion [(or (or (<= j k) (== j k)) (<= k j))]}

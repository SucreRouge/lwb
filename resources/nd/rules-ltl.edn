; lwb Logic WorkBench -- Natural deduction
; Rules for linear temporal logic

; Copyright (c) 2015 - 2016 Tobias VÃ¶lzel, Burkhardt Renz, THM. All rights reserved.
; The use and distribution terms for this software are covered by the
; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php).
; By using this software in any fashion, you are agreeing to be bound by
; the terms of this license.

;; all data regarding forward/backward of the rules are without engagement

; AND
{:id :and-i
 :given      [(at [i] phi) (at [i] psi)]
 :conclusion [(at [i] (and phi psi))]}
{:id :and-e1
 :given      [(at [i] (and phi psi))]
 :conclusion [(at [i] phi)]}
{:id :and-e2
 :given      [(at [i] (and phi psi))]
 :conclusion [(at [i] psi)]}

; OR
{:id :or-i1
 :given      [(at [i] phi)]
 :conclusion [(at [i] (or phi psi))]}
{:id :or-i2
 :given      [(at [i] psi)]
 :conclusion [(at [i] (or phi psi))]}
{:id :or-e
 :given      [(at [i] (or phi psi)) (infer (at [i] phi) (at [i] chi)) (infer (at [i] psi) (at[i] chi))]
 :conclusion [(at [i] chi)]}

; IMPL
{:id :impl-i
 :given      [(infer (at [i] phi) (at [i] psi))]
 :conclusion [(at [i] (impl phi psi))]}
{:id :impl-e
 :given      [(at [i] (impl phi psi)) (at [i] phi)]
 :conclusion [(at [i] psi)]}

; NOT
{:id :not-i
 :given      [(infer (at [j] phi) (at [i] contradiction))]
 :conclusion [(at [j] (not phi))]}
{:id :not-e
 :given      [(at [i] (not phi)) (at [i] phi)]
 :conclusion [(at [j] contradiction)]}

; RAA/EFQ
{:id :raa
 :given      [(infer (at [j] (not phi)) (at [i] contradiction))]
 :conclusion [(at [j] phi)]}
{:id :efq
 :given      [(at [i] contradiction)]
 :conclusion [(at [j] phi)]}

; for constants truth and contradiction
{:id :truth
 :given [(at [i] (or phi (not phi)))]
 :conclusion [(at [i] truth)]}
{:id :contradiction
 :given [(at [i] (not truth))]
 :conclusion [(at [i] contradiction)]}

; ATNEXT
{:id :atnext-i
 :given      [(at [j] phi) (succ i j)]
 :conclusion [(at [i] (atnext phi))]}
{:id :atnext-e
 :given      [(at [i] (atnext phi)) (succ i j)]
 :conclusion [(at [j] phi)]}

; ALWAYS
{:id :always-i
 :given      [(infer (<= i j) (at [j] phi))]
 :conclusion [(at [i] (always phi))]}
{:id :always-e 
 :given      [(at [i] (always phi)) (<= i j)]
 :conclusion [(at [j] phi)]}

; FINALLY
{:id :finally-i
 :given      [(at [j] phi) (<= i j)]
 :conclusion [(at [i] (finally phi))]}
{:id :finally-e
 :given      [(at [i] (finally phi))
              (infer [(<= i j)
                      (at [j] phi)]
                chi)]
 :conclusion [chi]}

; UNTIL
{:id :until-i
 :given      [(at [i] (finally psi))]
 :conclusion [(at [i] (until truth psi))]}
{:id :until-e
 :given      [(at [i] (until phi psi))]
 :conclusion [(at [i] (finally psi))]}
{:id :until-ind
 :given      [(at [i] (always (impl psi chi)))
              (at [i] (always (impl (and phi (atnext chi)) chi)))]
 :conclusion [(at [i] (impl (until phi psi) chi))]}
{:id :not-until
 :given      [(at [i] (not (until phi psi)))]
 :conclusion [(at [i] (or (always (not psi))
                          (until (not psi) (and (not phi) (not psi)))))]}

; RELATIONAL JUDGEMENTS
; concerning the model of time in LTL
; relation =
{:id :=refl
 :given      []
 :conclusion [(= i i)]}
{:id :=sym
 :given      [(= i j)]
 :conclusion [(= j i)]}
{:id :=trans
 :given      [(= i j) (= j k)]
 :conclusion [(= i k)]}
{:id :=fml
 :given      [(= i j) (at [i] phi)]
 :conclusion [(at [j] phi)]}
; weakening = to <=
{:id :=/<=
 :given      [(= i j)]
 :conclusion [(<= i j)]}

; relation <=
{:id :<=refl
 :given      []
 :conclusion [(<= i i)]}
{:id :<=serial
 :given      []
 :conclusion [(<= i j)]}
{:id :<=trans
 :given      [(<= i j) (<= j k)]
 :conclusion [(<= i k)]}

; relation <
{:id :<trans
 :given      [(< i j) (< j k)]
 :conclusion [(< i k)]}
{:id :linear
 :given      [(<= i j) (<= i k)]
 :conclusion [(or (< j k) (= j k) (< k j))]}
; weakening < <=
{:id :</<=
 :given      [(< i j)]
 :conclusion [(<= i j)]}

; relation succ
{:id :succ
 :given      []
 :conclusion [(succ i i')]}
; weakening succ to <
{:id :succ/<
 :given      [(succ i j)]
 :conclusion [(< i j)]}
; weakening succ to <= follows from succ/< and </<=
{:id :succ/<=
 :given      [(succ i j)]
 :conclusion [(<= i j)]}
; succ of two points in time
{:id :succ-succ-</<
 :given      [(succ i i') (succ j j') (< i j)]
 :conclusion [(< i' j')]}
{:id :succ-succ-<=/<=
 :given      [(succ i i') (succ j j') (<= i j)]
 :conclusion [(<= i' j')]}
{:id :succ-succ-<=/<=-b
 :given      [(succ i i') (succ j j') (<= i' j')]
 :conclusion [(<= i j)]}
{:id :succ-succ-=/=
 :given      [(succ i i') (succ j j') (= i j)]
 :conclusion [(= i' j')]}

; Elimination of or in relational judgments
{:id :rel-cases
 :given      [(or r1 r2 r3) (infer r1 chi) (infer r2 chi) (infer r3 chi)]
 :conclusion [chi]}


; lwb Logic WorkBench -- Natural deduction

; Copyright (c) 2015 - 2016 Tobias Völzel, Burkhardt Renz, THM. All rights reserved.
; The use and distribution terms for this software are covered by the
; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php).
; By using this software in any fashion, you are agreeing to be bound by
; the terms of this license.

;; all data regarding forward/backward of the rules are without engagement

;; AND
{:id :and-i
 :given      [(at [i] phi) (at [i] psi)]
 :conclusion [(at [i] (and phi psi))]
 :forward   true
 :backward  true}
{:id :and-e1
 :given      [(at [i] (and phi psi))]
 :conclusion [(at [i] phi)]
 :forward   true}
{:id :and-e2
 :given      [(at [i] (and phi psi))]
 :conclusion [(at [i] psi)]
 :forward   true}

;; OR
{:id :or-i1
 :given      [(at [i] phi)]
 :conclusion [(at [i] (or phi psi))]
 :forward   true
 :backward  true}
{:id :or-i2
 :given      [(at [i] psi)]
 :conclusion [(at [i] (or phi psi))]
 :forward   true
 :backward  true}
{:id :or-e1
 :given      [(at [i] (or phi psi)) (at [i] (not phi))]
 :conclusion [(at [i] psi)]
 :forward   true
 :backward  true}

;; kann man dies herleiten??
;; because of the nested structure of "(at i (or a b))" we need a rule for each side (a, b)
{:id :or-e2
 :given      [(at [i] (or phi psi)) (at [i] (not psi))]
 :conclusion [(at [i] phi)]
 :forward   true
 :backward  true}
;; De Morgan -- müsste man herleiten können
{:id :not-or
 :given      [(at [i] (not (or phi psi)))]
 :conclusion [(at [i] (and (not phi) (not psi)))]
 :forward   true
 :backward  true}

;; NOT
{:id :not-i
 :given      [(infer (at [j] phi) (at [i] contradiction))]
 :conclusion [(at [j] (not phi))]
 :backward  true}
{:id :not-e
 :given      [(at [i] (not (not phi)))]
 :conclusion [(at [i] phi)]
 :forward   true
 :backward  true}

;; IMPL
{:id :impl-i
 :given      [(infer (at [i] phi) (at [i] psi))]
 :conclusion [(at [i] (impl phi psi))]
 :backward  true}
{:id :impl-e
 :given      [(at [i] (impl phi psi)) (at [i] phi)]
 :conclusion [(at [i] psi)]
 :forward   true
 :backward  true}

;; ATNEXT
{:id :atnext-i
 :given      [(at [j] phi) (succ i j)]
 :conclusion [(at [i] (atnext phi))]
 :forward   true
 :backward  true}
{:id :atnext-e
 :given      [(at [i] (atnext phi)) (succ i j)]
 :conclusion [(at [j] phi)]
 :forward   true}

;; ALWAYS
{:id :always-i
 :given      [(infer (<= i j) (at [j] phi))]
 :conclusion [(at [i] (always phi))]
 :backward  true}
{:id :always-e 
 :given      [(<= i j) (at [i] (always phi))]
 :conclusion [(at [j] phi)]
 :forward   true}

;; FINALLY
{:id :finally-i
 :given      [(at [j] phi) (<= i j)]
 :conclusion [(at [i] (finally phi))]
 :forward   true
 :backward  true}
{:id :finally-e
 :given      [(at [i] (finally phi))]
 :conclusion [(<= i j) (at [j] phi)]
 :forward   true}

; kann man das herleiten??
{:id :not-finally
 :given      [(at [i] (not (finally phi)))]
 :conclusion [(at [i] (always (not phi)))]
 :forward   true
 :backward  true}

;; UNTIL
{:id :until-i
 :given      [(at [i] psi)]
 :conclusion [(at [i] (until phi psi))]
 :forward   true
 :backward  true}
{:id :until-e
 :given      [(at [i] (always (impl psi chi)))
              (at [i] (always (impl (and phi (atnext chi)) chi)))]
 :conclusion [(at [i] (impl (until phi psi) chi))]
 :backward  true}

; kann man das herleiten?
{:id :not-until
 :given      [(at [i] (not (until phi psi)))]
 :conclusion [(at [i] (or (always (not psi))
                         (until (not psi) 
                                (and (not phi) (not psi)))))]
 :forward   true}

;; RELATIONAL JUDGEMENTS
{:id :reflexivity
 :given      []
 :conclusion [(<= i j)]
 :forward   true}
{:id :atnext-seriality
 :given      []
 :conclusion [(succ i j)]
 :forward   true}
{:id :</<=
 :given      [(< i j)]
 :conclusion [(<= i j)]
 :forward   true}
{:id :atnext/<=
 :given      [(succ i j)]
 :conclusion [(<= i j)]
 :forward   true
 :backward  true}
{:id :transitivity
 :given      [(<= i j) (<= j k)]
 :conclusion [(<= i k)]
 :forward   true}
{:id :linearity
 :given      [(<= i j) (<= i k)]
 :conclusion [(or (or (<= j k) (== j k)) (<= k j))]
 :forward   true}

; Generated by lwb rev 1.0.0000 at 2016-11-22
; Do not edit.
 {:id :always-impl->impl-always, :given [(at [i] (always (impl A B)))], :conclusion [(at [i] (impl (always A) (always B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (impl A B)))} [{:plid 4, :body (at [i] (always A)), :roth :assumption, :refs nil} [{:plid 7, :body (<= i j), :roth :assumption, :refs nil} {:plid 10, :body (at [j] (impl A B)), :roth :always-e, :refs [1 7]} {:plid 11, :body (at [j] A), :roth :always-e, :refs [4 7]} {:plid 12, :body (at [j] B), :roth :impl-e, :refs [10 11]}] {:plid 6, :body (at [i] (always B)), :roth :always-i, :refs [[7 12]]}] {:plid 2, :body (at [i] (impl (always A) (always B))), :roth :impl-i, :refs [[4 6]]}]} {:id :atnext-not->not-atnext, :given [(at [i] (atnext (not A)))], :conclusion [(at [i] (not (atnext A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext (not A)))} {:plid 4, :body (succ i j), :roth :serial, :refs []} {:plid 5, :body (at [j] (not A)), :roth :atnext-e, :refs [1 4]} [{:plid 6, :body (at [i] (atnext A)), :roth :assumption, :refs nil} {:plid 9, :body (at [j] A), :roth :atnext-e, :refs [6 4]} {:plid 10, :body (at [j] contradiction), :roth :not-e, :refs [5 9]}] {:plid 2, :body (at [i] (not (atnext A))), :roth :not-i, :refs [[6 10]]}]}
 {:id :not-atnext->atnext-not, :given [(at [i] (not (atnext A)))], :conclusion [(at [i] (atnext (not A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (not (atnext A)))} {:plid 4, :body (succ i j), :roth :serial, :refs []} [{:plid 6, :body (at [j] A), :roth :assumption, :refs nil} {:plid 9, :body (at [i] (atnext A)), :roth :atnext-i, :refs [6 4]} {:plid 10, :body (at [j] contradiction), :roth :not-e, :refs [1 9]}] {:plid 5, :body (at [j] (not A)), :roth :not-i, :refs [[6 10]]} {:plid 2, :body (at [i] (atnext (not A))), :roth :atnext-i, :refs [5 4]}]}
 {:id :not-finally->always-not, :given [(at [i] (not (finally A)))], :conclusion [(at [i] (always (not A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (not (finally A)))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} [{:plid 7, :body (at [j] A), :roth :assumption, :refs nil} {:plid 10, :body (at [i] (finally A)), :roth :finally-i, :refs [7 4]} {:plid 9, :body (at [i] contradiction), :roth :not-e, :refs [1 10]}] {:plid 6, :body (at [j] (not A)), :roth :not-i, :refs [[7 9]]}] {:plid 2, :body (at [i] (always (not A))), :roth :always-i, :refs [[4 6]]}]}
 {:id :always-not->not-finally, :given [(at [i] (always (not A)))], :conclusion [(at [i] (not (finally A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (not A)))} [{:plid 4, :body (at [i] (finally A)), :roth :assumption, :refs nil} {:plid 7, :body (<= i j), :roth :finally-e, :refs [4]} {:plid 8, :body (at [j] A), :roth :finally-e, :refs [4]} {:plid 9, :body (at [j] (not A)), :roth :always-e, :refs [1 7]} {:plid 10, :body (at [j] contradiction), :roth :not-e, :refs [9 8]}] {:plid 2, :body (at [i] (not (finally A))), :roth :not-i, :refs [[4 10]]}]}
 {:id :finally-not->not-always, :given [(at [i] (finally (not A)))], :conclusion [(at [i] (not (always A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (finally (not A)))} [{:plid 4, :body (at [i] (always A)), :roth :assumption, :refs nil} {:plid 7, :body (<= i j), :roth :finally-e, :refs [1]} {:plid 8, :body (at [j] (not A)), :roth :finally-e, :refs [1]} {:plid 9, :body (at [j] A), :roth :always-e, :refs [4 7]} {:plid 6, :body (at [j] contradiction), :roth :not-e, :refs [8 9]}] {:plid 2, :body (at [i] (not (always A))), :roth :not-i, :refs [[4 6]]}]}
 {:id :notnot-e, :given [(at [i] (not (not A)))], :conclusion [(at [i] A)], :proof [{:plid 1, :roth :premise, :body (at [i] (not (not A)))} [{:plid 4, :body (at [i] (not A)), :roth :assumption, :refs nil} {:plid 7, :body (at [i] contradiction), :roth :not-e, :refs [1 4]}] {:plid 2, :body (at [i] A), :roth :raa, :refs [[4 7]]}]}
 {:id :always-notnot-e, :given [(at [i] (always (not (not A))))], :conclusion [(at [i] (always A))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (not (not A))))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 7, :body (at [j] (not (not A))), :roth :always-e, :refs [1 4]} {:plid 8, :body (at [j] A), :roth :notnot-e, :refs [7]}] {:plid 2, :body (at [i] (always A)), :roth :always-i, :refs [[4 8]]}]}
 {:id :not-always->finally-not, :given [(at [i] (not (always A)))], :conclusion [(at [i] (finally (not A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (not (always A)))} [{:plid 4, :body (at [i] (not (finally (not A)))), :roth :assumption, :refs nil} {:plid 7, :body (at [i] (always (not (not A)))), :roth :not-finally->always-not, :refs [4]} {:plid 8, :body (at [i] (always A)), :roth :always-notnot-e, :refs [7]} {:plid 9, :body (at [i] contradiction), :roth :not-e, :refs [1 8]}] {:plid 2, :body (at [i] (finally (not A))), :roth :raa, :refs [[4 9]]}]}
 {:id :atnext-impl->impl-atnext, :given [(at [i] (atnext (impl A B)))], :conclusion [(at [i] (impl (atnext A) (atnext B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext (impl A B)))} {:plid 4, :body (succ i j), :roth :serial, :refs []} [{:plid 5, :body (at [i] (atnext A)), :roth :assumption, :refs nil} {:plid 8, :body (at [j] (impl A B)), :roth :atnext-e, :refs [1 4]} {:plid 10, :body (at [j] A), :roth :atnext-e, :refs [5 4]} {:plid 11, :body (at [j] B), :roth :impl-e, :refs [8 10]} {:plid 7, :body (at [i] (atnext B)), :roth :atnext-i, :refs [11 4]}] {:plid 2, :body (at [i] (impl (atnext A) (atnext B))), :roth :impl-i, :refs [[5 7]]}]}
 {:id :always-serial, :given [(at [i] (always A))], :conclusion [(at [i] (and A (atnext (always A))))], :proof [{:plid 1, :roth :premise, :body (at [i] (always A))} {:plid 4, :body (succ i j), :roth :serial, :refs []} {:plid 5, :body (<= i i), :roth :reflexiv, :refs []} {:plid 9, :body (at [i] A), :roth :always-e, :refs [1 5]} [{:plid 11, :body (<= j k), :roth :assumption, :refs nil} {:plid 14, :body (<= i j), :roth :atnext/<=, :refs [4]} {:plid 15, :body (<= i k), :roth :transitiv, :refs [14 11]} {:plid 16, :body (at [k] A), :roth :always-e, :refs [1 15]}] {:plid 10, :body (at [j] (always A)), :roth :always-i, :refs [[11 16]]} {:plid 7, :body (at [i] (atnext (always A))), :roth :atnext-i, :refs [10 4]} {:plid 2, :body (at [i] (and A (atnext (always A)))), :roth :and-i, :refs [9 7]}]}
 {:id :atnext-and->and-atnext, :given [(at [i] (atnext (and A B)))], :conclusion [(at [i] (and (atnext A) (atnext B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext (and A B)))} {:plid 4, :body (succ i j), :roth :serial, :refs []} {:plid 5, :body (at [j] (and A B)), :roth :atnext-e, :refs [1 4]} {:plid 6, :body (at [j] A), :roth :and-e1, :refs [5]} {:plid 7, :body (at [j] B), :roth :and-e2, :refs [5]} {:plid 8, :body (at [i] (atnext A)), :roth :atnext-i, :refs [6 4]} {:plid 9, :body (at [i] (atnext B)), :roth :atnext-i, :refs [7 4]} {:plid 2, :body (at [i] (and (atnext A) (atnext B))), :roth :and-i, :refs [8 9]}]}
 {:id :and-atnext->atnext-and, :given [(at [i] (and (atnext A) (atnext B)))], :conclusion [(at [i] (atnext (and A B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (and (atnext A) (atnext B)))} {:plid 4, :body (at [i] (atnext A)), :roth :and-e1, :refs [1]} {:plid 5, :body (at [i] (atnext B)), :roth :and-e2, :refs [1]} {:plid 6, :body (succ i j), :roth :serial, :refs []} {:plid 7, :body (at [j] A), :roth :atnext-e, :refs [4 6]} {:plid 8, :body (at [j] B), :roth :atnext-e, :refs [5 6]} {:plid 9, :body (at [j] (and A B)), :roth :and-i, :refs [7 8]} {:plid 2, :body (at [i] (atnext (and A B))), :roth :atnext-i, :refs [9 6]}]}
 {:id :tnd, :given [], :conclusion [(at [i] (or P (not P)))], :proof [[{:plid 3, :body (at [i] (not (or P (not P)))), :roth :assumption, :refs nil} [{:plid 8, :body (at [i] P), :roth :assumption, :refs nil} {:plid 11, :body (at [i] (or P (not P))), :roth :or-i1, :refs [8]} {:plid 10, :body (at [i] contradiction), :roth :not-e, :refs [3 11]}] {:plid 7, :body (at [i] (not P)), :roth :not-i, :refs [[8 10]]} {:plid 6, :body (at [i] (or P (not P))), :roth :or-i2, :refs [7]} {:plid 5, :body (at [i] contradiction), :roth :not-e, :refs [3 6]}] {:plid 1, :body (at [i] (or P (not P))), :roth :raa, :refs [[3 5]]}]}
 {:id :always->finally, :given [(at [i] (always A))], :conclusion [(at [i] (finally A))], :proof [{:plid 1, :roth :premise, :body (at [i] (always A))} {:plid 4, :body (<= i j), :roth :serial, :refs []} {:plid 5, :body (at [j] A), :roth :always-e, :refs [1 4]} {:plid 2, :body (at [i] (finally A)), :roth :finally-i, :refs [5 4]}]}
 {:id :contrap, :given [(at [i] (impl A B))], :conclusion [(at [i] (impl (not B) (not A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (impl A B))} [{:plid 4, :body (at [i] (not B)), :roth :assumption, :refs nil} [{:plid 7, :body (at [i] A), :roth :assumption, :refs nil} {:plid 10, :body (at [i] B), :roth :impl-e, :refs [1 7]} {:plid 9, :body (at [i] contradiction), :roth :not-e, :refs [4 10]}] {:plid 6, :body (at [i] (not A)), :roth :not-i, :refs [[7 9]]}] {:plid 2, :body (at [i] (impl (not B) (not A))), :roth :impl-i, :refs [[4 6]]}]}
 {:id :always-tnd, :given [], :conclusion [(at [i] (always (or P (not P))))], :proof [[{:plid 3, :body (<= i j), :roth :assumption, :refs nil} {:plid 6, :body (at [j] (or P (not P))), :roth :tnd, :refs []}] {:plid 1, :body (at [i] (always (or P (not P)))), :roth :always-i, :refs [[3 6]]}]}

; lwb Logic WorkBench -- Propositional Logic SAT

; Copyright (c) 2014 - 2016 Burkhardt Renz, THM. All rights reserved.
; The use and distribution terms for this software are covered by the
; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php).
; By using this software in any fashion, you are agreeing to be bound by
; the terms of this license.

(ns lwb.prop.sat
  (:require [lwb.prop :refer :all]
            [clojure.set :refer (map-invert)]
            [clojure.string :refer (starts-with?)]
            [clojure.zip :as z]
            [clojure.spec :as s])
  (:import  (org.sat4j.minisat SolverFactory)
            (org.sat4j.core VecInt)
            (org.sat4j.specs ContradictionException)))

;; # Satisfiability in propositional logic

;; ## Transformation of a formula in cnf to dimacs format

;; A formula in dimacs format is organized as a map with the
;; following entries:

;; - `:formula`    the formula in cnf
;; - `:num-atoms`  the number of atoms in the formula
;; - `:int-atoms`  the mapping of integers in dimacs to the atoms 
;; - `:cl-set`     the set of clauses encoded with the integers

(s/def ::formula :lwb.prop/cnf)
(s/def ::num-atoms pos-int?)
(s/def ::int-atoms (s/map-of pos-int? atom?))
(s/def ::cl-set (s/coll-of set? :kind set? ))

(s/def ::dimacs (s/keys :req-un [::formula ::num-atoms ::int-atoms ::cl-set]))
;; Remark: obviously there are more constraints not yet expressed in this spec

(defn- cl2dimacs
  "Transforms a clause `cl` of the form `(or literal literal ...)` to a set
   of integers according to the mapping `atoms-int`."
  [cl atoms-int]
  (let [lit2int (fn [literal] 
                  (if (list? literal) (- ((second literal) atoms-int)) (literal atoms-int)))]
    (set (map lit2int  (rest cl)))))
  
(defn cnf2dimacs
  "Transforms `phi` in (standardized) cnf to a map with dimacs informations."
  [phi]
  (let [atoms     (atoms-of-phi phi)
        num-atoms (count atoms)
        atoms-int (zipmap atoms (range 1 (inc num-atoms)))
        cl-set    (set (map #(cl2dimacs % atoms-int) (rest phi)))]
    {:formula   phi
     :num-atoms num-atoms
     :int-atoms (map-invert atoms-int)
     :num-cl    (count cl-set)
     :cl-set    cl-set}))

(s/fdef cnf2dimacs
        :args (s/cat :phi ::formula)
        :ret ::dimacs)

;; ## SAT4J
(def ^:dynamic *sat4j-timeout*
  "Timeout of Sat4j in seconds."
  300)

(defn sat4j-solve
  "Checks whether the formula in `dimacs-map` is satisfiable.   
   Returns nil if not, an assignment vector if it is satisfiable." 
  [dimacs-map]
  (let [solver     (SolverFactory/newDefault)
        cl-set     (:cl-set dimacs-map)
        num-atoms  (:num-atoms dimacs-map)
        num-cl     (:num-cl dimacs-map)
        make-model (fn [model int-atoms]
                     (vec (flatten 
                            (map #(if (pos? %) 
                                    [(int-atoms %) true] 
                                    [(int-atoms (- %)) false]) model))))]
    (try
      (.setTimeout solver *sat4j-timeout*)
      (.newVar solver num-atoms)
      (.setExpectedNumberOfClauses solver num-cl)

      (dorun (map #(.addClause solver (VecInt. (int-array %))) cl-set))

      (when (.isSatisfiable solver)
        (make-model (vec (.model solver)) (:int-atoms dimacs-map)))
      (catch ContradictionException _ nil))))

(s/fdef sat4j-solve
        :args (s/cat :dimacs-map ::dimacs)
        :ret (s/or :model :lwb.prop/model :nil nil?))

;; ## Tseitin transformation

;; The Tseitin transformation takes a formula `phi` and generates in linear time
;; a formula which is equivalent with respect to satisfiability.

;; New atoms generated by the Tseitin transformation have the prefix "ts" followed by an int
(def tseitin-prefix
  "Prefix for tseitin symbols."
  "ts")

(defn- tseitin-symbol-generator
  "A function that generates unique tseitin symbols,
   beginning with `ts1`."
  []
  (let [cnt    (atom 0)]
    #(symbol (str tseitin-prefix (swap! cnt inc)))))

(defn- mark-phi
  "Marks each branch of `phi` with a unique tseitin symbol.   
   The root has the symbol `ts1`."
  [phi]
  (let [tsg     (tseitin-symbol-generator)
        zipper  (z/seq-zip phi)
        mark-fn (fn [node] (vary-meta node assoc :tseitin-symbol (tsg)))]
    (loop [loc zipper]
      (if (z/end? loc)
        (z/root loc)
        (recur (z/next (if (z/branch? loc) (z/edit loc mark-fn) loc)))))))

(defn- locs-phi
  "Sequence of all the locations of a zipper generated from the formula `phi`."
  [phi]
  (take-while (complement z/end?) (iterate z/next (z/seq-zip phi))))

(defn- iterate-while
  "Iterate beginning with `x` while `f` returns not nil"
  [f x]
   (lazy-seq (when x (cons x (iterate-while f (f x))))))

(defn- children-locs
  "Sequence of children locs at branch"
  [branch]
  (iterate-while z/right (z/down branch)))

(defn- tseitin-branch
  "Analyzes branch and generates equivalence formula for the branch.  
   The formula is of the form `(equiv tsx (atoms or tseitin symbol of children))`."
  [branch]
  (let [children (map #(if (z/branch? %) (:tseitin-symbol (meta  (z/node %))) (z/node %)) (children-locs branch))]
    (list 'equiv (:tseitin-symbol (meta (z/node branch))) children)))
                                 
(defn tseitin
  "Tseitin transformation for formula `phi`.   
   (1) The formula is marked with tseitin symbols for the branches.    
   (2) The tseitin equivalences for the branches are generated.  
   (3) CNF of these is calculated.    
   (4) The final formula with `ts1` for the root is build and simplified."
  [phi]
  (cond
    ; border cases
    (boolean? phi) phi
    (atom? phi) (list 'and (list 'or phi))
    ; actual transformation
    :else
		  (let [parts (map cnf (map tseitin-branch (filter z/branch? (locs-phi (mark-phi phi)))))]
		    (flatten-ops (cons 'and (cons '(and (or ts1)) parts))))))

(s/fdef tseitin
        :args (s/cat :phi wff?)
        :ret :lwb.prop/cnf)

(defn- remove-tseitin-symbols
  "Removes the tseitin-symbols and their value from a model."
  [model]
  (let [zipper (z/vector-zip model)]
    (loop [loc zipper]
      (if (z/end? loc)
        (z/root loc)
        (recur (z/next (if (starts-with? (str (z/node loc)) tseitin-prefix) (z/remove (z/next (z/remove loc))) loc)))))))

(defn- model2negated-cnf
  "Transforms a model into a formula in cnf with negated truth value."
  [model]
  (let [pairs (partition 2 model)
        negate (fn [[atom value]] (if value (list 'not atom) atom))]
    (apply list 'or (map negate pairs))))
    
(defn sat
  "Gives a model for `phi` if the formula is satisfiable, nil if not.   
   If `phi` is trivially valid, the result is true.   
   Mode `:all` returns a sequence of all the satisfying assignments."
  ([phi]
    (sat phi :one))
  ([phi mode]
    (cond
	   ; border cases
     (= phi 'true) true
     (= phi 'false) nil
     :else
	     (case mode
	       :all 
		       (loop  [f phi, results '()]
		        (let [sol (sat f)]
	             (if (nil? sol) results
		               (recur (list 'and (model2negated-cnf sol) f) (conj results sol)))))
	       ; default
		       (let [tcnf   (if (cnf? phi) phi (tseitin phi))
		             dimacs (cnf2dimacs tcnf)
		             res    (sat4j-solve dimacs)]
		         (when res
		           (remove-tseitin-symbols res)))))))

(s/fdef sat
        :args (s/alt :1-args (s/cat :phi wff?)
                     :2-args (s/cat :phi wff? :mode #{:one :all}))
        :ret (s/or :lwb.prop/model boolean?))

(defn sat?
  "Is `phi` satisfiable?"
  [phi]
  (if (nil? (sat phi)) false true))

(s/fdef sat?
        :args (s/cat :phi wff?)
        :ret boolean?)

(defn valid?
  "Is `phi` valid?"
  [phi]
  (not (sat? (list 'not phi))))

(s/fdef valid?
        :args (s/cat :phi wff?)
        :ret boolean?)

(defn true-only
  "Sequence of true atoms in a model"
  [model]
  (loop [vec model, result []]
    (if (empty? vec)
      result
      (let [atom (first vec) value (second vec)]
        (recur (subvec vec 2) (if value (conj result atom) result))))))

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1449651489628">{:repl-history {:ide [], :local [&quot;(ns lwb.pred\n  (:require [lwb.lang :refer :all]))&quot; &quot;(defn sarity\n  \&quot;Arity of `symb` in signature `sig`\&quot;\n  [symb sig]\n  (second ((keyword symb) sig)))&quot; &quot;(ns lwb.pred\n  (:refer-clojure :exclude [var?]) \n  (:require [lwb.lang :refer :all]))&quot; &quot;(defn var?\n  \&quot;Is `symb` a variable with respect to signature `sig`?\&quot;\n  [symb sig]\n  (if (not (symbol? symb))\n    false\n    (not (or (op? symb) (torf? symb) (quantor? symb) (const? symb sig)\n           (func? symb sig) (pred? symb sig) (prop? symb sig)))))&quot; &quot;(declare term?)&quot; &quot;(defn compound-term?\n  \&quot;Is `texpr` a compound term expression with respect to signatur `sig`?\&quot;\n  [texpr sig]\n  (cond\n    (not (list? texpr)) (throw (IllegalStateException. (str \&quot;expected list, got \&quot; texpr)))\n    (empty? texpr) (throw (IllegalStateException. \&quot;expected not empty list, got '()'.\&quot;))\n    (not (func? (first texpr) sig)) \n      (throw (IllegalStateException. (str \&quot;expected function, got \&quot; texpr)))\n    :else (let [a (sarity (first texpr) sig)] \n            (if (not= (count texpr) (inc a))\n              (throw (IllegalStateException. (str \&quot;expected arity \&quot; a \&quot;, got \&quot; texpr)))\n              (every? #(term? % sig) (rest texpr))))))&quot; &quot;(defn simple-term?\n  \&quot;Is `symb` a single term with respect to `sig`?\&quot;\n  [symb sig]\n  (if (not (symbol? symb))\n    false\n    (or (var? symb sig) (const? symb sig))))&quot; &quot;(defn term?\n  \&quot;Is `texpr` a term?\&quot;\n  [texpr sig]\n  (or (simple-term? texpr sig) (compound-term? texpr sig)))&quot; &quot;(defn pred?\n  \&quot;Is `phi` a predicate with respect to the signature `sig`\&quot;\n  [phi sig]\n  (if (or (not (list? phi)) (not (pred? (first phi) sig)))\n    false\n    (let [a (sarity (first phi) sig)]\n      (if (not= (count phi) (inc a))\n        (throw (IllegalStateException. (str \&quot;expected arity \&quot; a \&quot;, got \&quot; phi)))\n        (every? #(term? % sig) (rest phi))))))&quot; &quot;(defn equality?\n  \&quot;Is `phi` the equality predicate with respect to the signature `sig`\&quot;\n  [phi sig]\n  (if (or (not (list? phi)) (not (eq? (first phi) sig)))\n    false\n    (if (not= (count phi) 3)\n        (throw (IllegalStateException. (str \&quot;expected arity 2, got \&quot; phi)))\n        (every? #(term? % sig) (rest phi)))))&quot; &quot;(defn decl?\n  \&quot;Is the given vector a vector of variables with respect to signature `sig`?\&quot;\n  [decl sig]\n  (if (and (vector? decl) (every? #(var? % sig) decl)) \n    true\n    (throw (IllegalStateException. (str \&quot;expected vector of variables, got \&quot; decl)))))&quot; &quot;(defn quantified?\n  \&quot;Is `qexpr` a quantified first order formula with respect to `sig`?\&quot;\n  [qexpr sig]\n  (if (or (not (list? qexpr)) (not (quantor? (first qexpr))))\n    false\n    (let [decl (second qexpr)\n          phi  (nth qexpr 2)]\n      (if (not (and (decl? decl sig) (wff? phi sig)))\n        (throw (IllegalStateException. (str \&quot;expected quantified formula, got \&quot; qexpr)))\n        true))))&quot; &quot;(defn simple-expr?\n  [phi sig]\n  (or (torf? phi) (prop? phi sig) (pred? phi sig)))&quot; &quot;(declare wff?)&quot; &quot;(defn simple-expr?\n  [phi sig]\n  (or (torf? phi) (prop? phi sig) (pred? phi sig) (equality? phi sig)))&quot; &quot;(defn compound-expr\n  [phi sig]\n  (cond\n    (not (list? phi)) (throw (IllegalStateException. (str \&quot;expected list, got \&quot; phi)))\n    (empty? phi) (throw (IllegalStateException. \&quot;expected not empty list, got '()'.\&quot;))\n    (not (or (op? (first phi)) (quantor? (first phi)))) (throw \n                                                 (IllegalStateException. (str \&quot;expected operator or quantor, got \&quot; phi)))\n    :else (or (unary-expr? phi sig) (binary-expr? phi sig) \n              (ternary-expr? phi sig) (nary-expr? phi sig)\n              (quantified? phi sig))))&quot; &quot;(defn unary-expr?\n  [phi sig]\n  (if (not (unary? (first phi)))\n    false\n    (if (not= 2 (count phi))\n      (throw (IllegalStateException. (str \&quot;expected unary expression, got \&quot; phi)))\n      (wff? (second phi) sig))))&quot; &quot;(defn binary-expr?\n  [phi sig]\n  (if (not (binary? (first phi)))\n    false\n    (if (not= 3 (count phi))\n      (throw (IllegalStateException. (str \&quot;expected binary expression, got \&quot; phi)))\n      (every? #(wff? % sig) (rest phi)))))&quot; &quot;(defn ternary-expr?\n  [phi sig]\n  (if (not (ternary? (first phi)))\n    false\n    (if (not= 4 (count phi))\n      (throw (IllegalStateException. (str \&quot;expected ternary expression, got \&quot; phi)))\n      (every? #(wff? % sig) (rest phi)))))&quot; &quot;(defn nary-expr?\n  [phi sig]\n  (if (not (nary? (first phi)))\n    false\n    (every? #(wff? % sig) (rest phi))))&quot; &quot;(defn op-expr?\n  [phi]\n  (if (not (op? (first phi)))\n    false\n    (let [a (arity (first phi))\n          c (dec (count phi))]\n      (if (and (not= a -1) (not= a c))\n        (throw (IllegalStateException. (str \&quot;expected operator with arity \&quot; a \&quot;, got \&quot; phi)))\n        (every? wff? (rest phi))))))&quot; &quot;(wff? '(or (and x1 x2 x3 x4 x5) y z))&quot; &quot;(wff? '(xor (and x1 x2 x3 x4 x5) y z))&quot; &quot;(wff? '(xor (and x1 x2 x3 x4 x5) y z) :msg)&quot; &quot;(defn compound-expr\n  [phi sig]\n  (cond\n    (not (list? phi)) (throw (IllegalStateException. (str \&quot;expected list, got \&quot; phi)))\n    (empty? phi) (throw (IllegalStateException. \&quot;expected not empty list, got '()'.\&quot;))\n    (not (or (op? (first phi)) (quantor? (first phi)))) (throw \n                                                 (IllegalStateException. (str \&quot;expected operator or quantor, got \&quot; phi)))\n    :else (or (op-expr? phi sig) (quantified? phi sig))))&quot; &quot;(defn op-expr?\n  [phi sig]\n  (if (not (op? (first phi)))\n    false\n    (let [a (arity (first phi))\n          c (dec (count phi))]\n      (if (and (not= a -1) (not= a c))\n        (throw (IllegalStateException. (str \&quot;expected operator with arity \&quot; a \&quot;, got \&quot; phi)))\n        (every? #(wff? % sig) (rest phi))))))&quot; &quot;(defn wff?\n  \&quot;Is the first order formula `phi` well-formed, with respect to signature `sig` ?\n   `(fof-wff? phi sig)` returns true or false   \n   `(fof-wff? phi sig :msg)` returns true or a message on the error in `phi`.\&quot;\n  ([phi sig]\n   (wff? phi sig :bool))\n  ([phi sig mode]\n   (try\n     (or (simple-expr? phi sig) (compound-expr phi sig))\n     (catch Exception e (if (= mode :msg) (.getMessage e) false)))))&quot; &quot;(ns lwb.pred\n  (:refer-clojure :exclude [var?])\n  (:require [lwb.prop :as prop]\n            [potemkin :as pot]))&quot; &quot;(defn- sig-what\n  [type symb sig]\n  (and (symbol? symb) (= (first ((keyword symb) sig)) type)))&quot; &quot;(defn const?\n  \&quot;Is `symb` a constant in the signatur `sig`\&quot;\n  [symb sig]\n  (sig-what :const symb sig))&quot; &quot;(defn func?\n  \&quot;Is `symb` a function in the signatur `sig`\&quot;\n  [symb sig]\n  (sig-what :func symb sig))&quot; &quot;(defn prop?\n  \&quot;Is `symb` an atomic proposition in the signatur `sig`\&quot;\n  [symb sig]\n  (sig-what :prop symb sig))&quot; &quot;(defn arity\n  \&quot;Arity of operator `op` or of `symb` in signature `sig`\&quot;\n  ([op]\n   (prop/arity op))\n  ([symb sig]\n    (second ((keyword symb) sig))))&quot; &quot;(deftest sig-test\n  (is (= true  (const? 'c  sig)))\n  (is (= true  (const? 'd  sig)))\n  (is (= false (const? 'f1 sig)))\n  (is (= true  (func?  'f1 sig)))\n  (is (= false (func?  'P1 sig)))\n  (is (= true  (prop?  'r  sig)))\n  (is (= false (prop?  'd  sig)))\n  (is (= true  (pred?  'P1 sig)))\n  (is (= true  (pred?  'P2 sig)))\n  (is (= false (pred?  'f3 sig))))&quot; &quot;(sig-test)&quot; &quot;(pot/import-vars\n  [lwb.prop impl equiv xor ite\n            op? torf? atom?])&quot; &quot;(macro-expand1 '(impl a b))&quot; &quot;(deftest symb-test\n  (is (= true  (op? 'and)))\n  (is (= true  (const? 'd  sig)))\n  (is (= false (const? 'f1 sig)))\n  (is (= true  (func?  'f1 sig)))\n  (is (= false (func?  'P1 sig)))\n  (is (= true  (prop?  'r  sig)))\n  (is (= false (prop?  'd  sig)))\n  (is (= true  (pred?  'P1 sig)))\n  (is (= true  (pred?  'P2 sig)))\n  (is (= false (pred?  'f3 sig))))&quot; &quot;(deftest symb-test\n  (is (= true  (op? 'and)))\n  (is (= true  (torf? 'true)))\n  (is (= false (const? 'f1 sig)))\n  (is (= true  (func?  'f1 sig)))\n  (is (= false (func?  'P1 sig)))\n  (is (= true  (prop?  'r  sig)))\n  (is (= false (prop?  'd  sig)))\n  (is (= true  (pred?  'P1 sig)))\n  (is (= true  (pred?  'P2 sig)))\n  (is (= false (pred?  'f3 sig))))&quot; &quot;nt&quot; &quot;(defn quantor?\n  \&quot;Is `symb` a quantor?\&quot;\n  [symb]\n  (or (= 'forall symb) (= 'exists symb)))&quot; &quot;(deftest symb-test\n  (is (= true  (op? 'and)))\n  (is (= true  (torf? 'true)))\n  (is (= true  (quantor? 'forall)))\n  (is (= false (quantor? 'all)))\n  (is (= true  (func?  'f1 sig)))\n  (is (= false (func?  'P1 sig)))\n  (is (= true  (prop?  'r  sig)))\n  (is (= false (prop?  'd  sig)))\n  (is (= true  (pred?  'P1 sig)))\n  (is (= true  (pred?  'P2 sig)))\n  (is (= false (pred?  'f3 sig))))&quot; &quot;(defn eq?\n  \&quot;Is `symb` equality in predicate logic??\&quot;\n  [symb]\n  (= 'eq symb))&quot; &quot;(ns lwb.pred-test\n (:require [clojure.test :refer :all]\n           [lwb.pred :refer :all]))&quot; &quot;(deftest symb-test\n  (is (= true  (op? 'and)))\n  (is (= true  (torf? 'true)))\n  (is (= true  (quantor? 'forall)))\n  (is (= false (quantor? 'all)))\n  (is (= true  (eq?  'eq)))\n  (is (= false (func?  'P1 sig)))\n  (is (= true  (prop?  'r  sig)))\n  (is (= false (prop?  'd  sig)))\n  (is (= true  (pred?  'P1 sig)))\n  (is (= true  (pred?  'P2 sig)))\n  (is (= false (pred?  'f3 sig))))&quot; &quot;(deftest symb-test\n  (is (= true  (op? 'and)))\n  (is (= true  (torf? 'true)))\n  (is (= true  (quantor? 'forall)))\n  (is (= false (quantor? 'all)))\n  (is (= true  (eq?  'eq)))\n  (is (= false (eq?  '=)))\n  (is (= false (func?  'P1 sig)))\n  (is (= true  (prop?  'r  sig)))\n  (is (= false (prop?  'd  sig)))\n  (is (= true  (pred?  'P1 sig)))\n  (is (= true  (pred?  'P2 sig)))\n  (is (= false (pred?  'f3 sig))))&quot; &quot;(defn var?\n  \&quot;Is `symb` a variable with respect to signature `sig`?\&quot;\n  [symb sig]\n  (if (not (symbol? symb))\n    false\n    (not (or (op? symb) (torf? symb) (quantor? symb) (eq? symb)\n             (const? symb sig) (func? symb sig) (pred? symb sig) (prop? symb sig)))))&quot; &quot;(deftest symb-test\n  (is (= true  (op? 'and)))\n  (is (= true  (torf? 'true)))\n  (is (= true  (quantor? 'forall)))\n  (is (= false (quantor? 'all)))\n  (is (= true  (eq?  'eq)))\n  (is (= false (eq?  '=)))\n  (is (= true  (var?  'x sig)))\n  (is (= true  (var?  'y sig)))\n  (is (= true  (var?  'y sig)))\n  (is (= true  (prop?  'r  sig)))\n  (is (= false (prop?  'd  sig)))\n  (is (= true  (pred?  'P1 sig)))\n  (is (= true  (pred?  'P2 sig)))\n  (is (= false (pred?  'f3 sig))))&quot; &quot;(deftest symb-test\n  (is (= true  (op? 'and)))\n  (is (= true  (torf? 'true)))\n  (is (= true  (quantor? 'forall)))\n  (is (= false (quantor? 'all)))\n  (is (= true  (eq?  'eq)))\n  (is (= false (eq?  '=)))\n  (is (= true  (var?  'x sig)))\n  (is (= true  (var?  'y sig)))\n  (is (= false (var?  'c sig)))\n  (is (= true  (prop?  'r  sig)))\n  (is (= false (prop?  'd  sig)))\n  (is (= true  (pred?  'P1 sig)))\n  (is (= true  (pred?  'P2 sig)))\n  (is (= false (pred?  'f3 sig))))&quot; &quot;sig&quot; &quot;(defn pred?\n  \&quot;Is `symb` a predicate in the signatur `sig`\&quot;\n  [symb sig]\n  (sig-what :pred symb sig))&quot; &quot;(pred? 'P1 sig)&quot; &quot;(deftest term-test\n  (is (= true (term? 'x sig)))\n  )&quot; &quot;(deftest term-test\n  (is (= true (term? 'x sig)))\n  (is (= true (term? 'f sig)))\n  )&quot; &quot;(deftest term-test\n  (is (= true (term? 'x sig)))\n  (is (= true (term? 'f1 sig)))\n  )&quot; &quot;(deftest term-test\n  (is (= true (term? 'x sig)))\n  (is (= true (term? '(f1 y) sig)))\n  )&quot; &quot;(deftest term-test\n  (is (= true (term? 'x sig)))\n  (is (= true (term? '(f1 y) sig)))\n  (is (= true (term? '(f1 c) sig)))\n  )&quot; &quot;(deftest term-test\n  (is (= true (term? 'x sig)))\n  (is (= true (term? '(f1 y) sig)))\n  (is (= true (term? '(f1 c) sig)))\n  (is (= true (term? '(f3 x y z) sig)))\n  )&quot; &quot;(deftest term-test\n  (is (= true (term? 'x sig)))\n  (is (= true (term? '(f1 y) sig)))\n  (is (= true (term? '(f1 c) sig)))\n  (is (= true (term? '(f3 x y z) sig)))\n  (is (= true (term? '(f3 (f1 x) (f2 y1 y2) z) sig)))\n  )&quot; &quot;(deftest term-test\n  (is (= true (term? 'x sig)))\n  (is (= true (term? '(f1 y) sig)))\n  (is (= true (term? '(f1 c) sig)))\n  (is (= true (term? '(f3 x y z) sig)))\n  (is (= true (term? '(f3 (f1 x) (f2 y1 y2) z) sig)))\n  (is (= false (term? 'r sig)))\n  )&quot; &quot;(deftest term-test\n  (is (= true (term? 'x sig)))\n  (is (= true (term? '(f1 y) sig)))\n  (is (= true (term? '(f1 c) sig)))\n  (is (= true (term? '(f3 x y z) sig)))\n  (is (= true (term? '(f3 (f1 x) (f2 y1 y2) z) sig)))\n  (is (thrown? IllegalStateException (term? 'r sig)))\n  )&quot; &quot;(is (thrown? IllegalStateException (equality? '(eq r x) sig)))&quot; &quot;(defn equality?\n  \&quot;Is `phi` the equality predicate with respect to the signature `sig`\&quot;\n  [phi sig]\n  (if (or (not (list? phi)) (not (eq? (first phi))))\n    false\n    (if (not= (count phi) 3)\n        (throw (IllegalStateException. (str \&quot;expected arity 2, got \&quot; phi)))\n        (every? #(term? % sig) (rest phi)))))&quot; &quot;(deftest predicate-test\n  (is (= true (predicate? '(P2 x y) sig)))\n  (is (= true (predicate? '(P2 x (f1 y)i) sig)))\n  (is (= true (predicate? '(P1 (f1 c)) sig)))\n  (is (= true (predicate? '(f3 x y z) x) sig)))&quot; &quot;(deftest predicate-test\n  (is (= true (predicate? '(P2 x y) sig)))\n  (is (= true (predicate? '(P2 x (f1 y)i) sig)))\n  (is (= true (predicate? '(P1 (f1 c)) sig)))\n  (is (= true (predicate? '((f3 x y z) x) sig)))\n\n(is (thrown? IllegalStateException (equality? '(eq r x) sig))))&quot; &quot;(deftest predicate-test\n  (is (= true (predicate? '(P2 x y) sig)))\n  (is (= true (predicate? '(P2 x (f1 y)i) sig)))\n  (is (= true (predicate? '(P1 (f1 c)) sig)))\n  (is (= true (predicate? '((f3 x y z) x) sig)))\n  (is (thrown? IllegalStateException (predicate? '(eq r x) sig))))&quot; &quot;(deftest predicate-test\n  (is (= true (predicate? '(P2 x y) sig)))\n  (is (= true (predicate? '(P2 x (f1 y)i) sig)))\n  (is (= true (predicate? '(P1 (f1 c)) sig)))\n  (is (= false (predicate? '((f3 x y z) x) sig)))\n  (is (thrown? IllegalStateException (predicate? '(P2 x x x) sig))))&quot; &quot;(deftest predicate-test\n  (is (= true (predicate? '(P2 x y) sig)))\n  (is (= true (predicate? '(P2 x (f1 y)) sig)))\n  (is (= true (predicate? '(P1 (f1 c)) sig)))\n  (is (= false (predicate? '((f3 x y z) x) sig)))\n  (is (thrown? IllegalStateException (predicate? '(P2 x x x) sig))))&quot; &quot;(deftest wff-test\n  (is (= true (wff? '(forall [x y] (P2 x y))))))&quot; &quot;(deftest wff-test\n  (is (= true (wff? '(forall [x y] (P2 x y)) sig))))&quot; &quot;(deftest wff-test\n  (is (= true (wff? '(forall [x y] (P2 x y)) sig)))\n  (is (= true (wff? '(exists [x y] (and (P1 x) (P1 y))) sig)))\n  )&quot; &quot;(deftest wff-test\n  (is (= true (wff? '(forall [x y] (P2 x y)) sig)))\n  (is (= true (wff? '(exists [x y] (and (P1 x) (P1 y))) sig)))\n  (is (= true (wff? '(exists [x y] (and (P1 x) (eq x y))) sig)))\n  )&quot; &quot;(deftest wff-test\n  (is (= true (wff? '(forall [x y] (P2 x y)) sig)))\n  (is (= true (wff? '(exists [x y] (and (P1 x) (P1 y))) sig)))\n  (is (= true (wff? '(exists [x y] (and (P1 x) (eq x y))) sig)))\n  (is (= true (wff? '(forall [x] (exists [y] (P2 x y))) sig)))\n  )&quot; &quot;(deftest wff-test\n  (is (= true (wff? '(forall [x y] (P2 x y)) sig)))\n  (is (= true (wff? '(exists [x y] (and (P1 x) (P1 y))) sig)))\n  (is (= true (wff? '(exists [x y] (and (P1 x) (eq x y))) sig)))\n  (is (= true (wff? '(forall [x] (exists [y] (P2 x y))) sig)))\n  (is (= true (wff? '(P2 x y) sig)))\n  )&quot; &quot;(deftest wff-test\n  (is (= true (wff? '(forall [x y] (P2 x y)) sig)))\n  (is (= true (wff? '(exists [x y] (and (P1 x) (P1 y))) sig)))\n  (is (= true (wff? '(exists [x y] (and (P1 x) (eq x y))) sig)))\n  (is (= true (wff? '(forall [x] (exists [y] (P2 x y))) sig)))\n  (is (= true (wff? '(P2 x y) sig)))\n  (is (= true (wff? '(ite (P2 x y) r (eq c d)) sig)))\n  )&quot; &quot;(deftest equality-test\n  (is (= true (equality? '(eq x y) sig)))\n  (is (= true (equality? '(eq x (f1 y)i) sig)))\n  (is (= true (equality? '(eq (f1 c) d) sig)))\n  (is (= true (equality? '(f3 x y z) x) sig)))&quot; &quot;(deftest equality-test\n  (is (= true (equality? '(eq x y) sig)))\n  (is (= true (equality? '(eq x (f1 y)i) sig)))\n  (is (= true (equality? '(eq (f1 c) d) sig)))\n  (is (= true (equality? '(eq (f3 x y z) x) sig)))\n  (is (thrown? IllegalStateException (equality? '(eq r x) sig))))&quot; &quot;(deftest equality-test\n  (is (= true (equality? '(eq x y) sig)))\n  (is (= true (equality? '(eq x (f1 y)) sig)))\n  (is (= true (equality? '(eq (f1 c) d) sig)))\n  (is (= true (equality? '(eq (f3 x y z) x) sig)))\n  (is (thrown? IllegalStateException (equality? '(eq r x) sig))))&quot; &quot;(run-tests)&quot; &quot;impl-test'&quot; &quot;(impl-test)&quot; &quot;(impl-test')&quot; &quot;(macroexpand-1 '(impl a b))&quot; &quot;(ns lwb.pred-test\n  (:refer-clojure :exclude [var?])\n  (:require [clojure.test :refer :all]\n            [lwb.pred :refer :all]))&quot; &quot;(def sig {:c  [:const 0]\n          :d  [:const 0]\n          :f1 [:func 1]\n          :f2 [:func 2]\n          :f3 [:func 3]\n          :r  [:prop 0]\n          :P1 [:pred 1]\n          :P2 [:pred 2]})&quot; &quot;(deftest op-test\n  (is (= '(or (not a) b) (macroexpand-1 '(impl a b)))))&quot; &quot;(op-test)&quot; &quot;(ns lwb.prop-test\n  (:require [clojure.test :refer :all]\n            [lwb.prop :refer :all]))&quot; &quot;(deftest impl-test\n  (is (= true (impl true true)))\n  (is (= false (impl true false)))\n  (is (= true (impl false true)))\n  (is (= true (impl false false))))&quot; &quot;(deftest impl-test'\n  (is (= '(or (not a) b) (macroexpand-1 '(impl a b)))))&quot; &quot;(ns lwb.nd.repl\n  (:require [lwb.nd.deduction :as deduc]\n            [lwb.nd.prereqs :refer :all]\n            [lwb.nd.io :as io]\n            [lwb.nd.printer :refer [pprint]]))&quot; &quot;(io/import-rules \&quot;resources/nd/rules-prop-pred.clj\&quot;)&quot; &quot;(io/import-trivials \&quot;resources/nd/trivial-theorems.clj\&quot;)&quot; &quot;(io/import-theorems \&quot;resources/nd/theorems.clj\&quot;)&quot; &quot;(proof '[a b] '(and a b))&quot; &quot;(step-f \&quot;and-i\&quot; 1 2)&quot; &quot;(choose-option 3 1)&quot; &quot;(step-f \&quot;impl-e\&quot; 1 3)&quot; &quot;(step-f \&quot;not-e\&quot; 2 4)&quot; &quot;(proof '[(impl a b) (not b)] '(not a))&quot; &quot;(step-b \&quot;not-i\&quot; 4)&quot;], :remote []}}</component>
</project>
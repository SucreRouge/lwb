<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1421313818549">{:repl-history {:ide [], :local [&quot;(defn sat?\n  \&quot;Is `phi` satisfiable?\&quot;\n  [phi]\n  (if (nil? (sat phi)) false true))&quot; &quot;(list not p)&quot; &quot;(list not 'p)&quot; &quot;(sat? 'p)&quot; &quot;(sat? '(or p q))&quot; &quot;(defn valid?\n  \&quot;Is `phi` valid?\&quot;\n  [phi]\n  (not (sat? (list 'not phi))))&quot; &quot;(valid? 'p)&quot; &quot;(valid? '(and p q))&quot; &quot;(valid? '(or p (not p)))&quot; &quot;(sat? '(not (or p (not p))))&quot; &quot;(sat? '(and p (not p)))&quot; &quot;(valid? '(not (and p (not p))))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch \&quot; \&quot;))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch \&quot;\&quot;))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch \&quot; \&quot;)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch ))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch ))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch \&quot; \&quot;)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch ))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch ))\n            (= 0 (mod col n1)) (print ch \&quot; \&quot;)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(pretty-print demopuzzle)&quot; &quot;(pretty-print (solve demopuzzle))&quot; &quot;(parse \&quot;resources/sudoku/easy50.txt\&quot;)&quot; &quot;bench1&quot; &quot;(bench1)&quot; &quot;(time\n  (bench1))&quot; &quot;(defn bench2\n  []\n  (let [puzzles (parse \&quot;resources/sudoku/top95.txt\&quot;)]\n    (map solve puzzles)))&quot; &quot;(time\n  (doall (bench2)))&quot; &quot;(def digits\n  \&quot;Digits for cells\&quot;\n  (map #(char (+ (int \\0) %)) (range 1 (inc n2))))&quot; &quot;(def cell-cl\n  (let [cell-syms (partition n2 (for [r nums c nums v nums]\n                 (make-sym [r c v])))]\n    (mapcat oneof cell-syms)))&quot; &quot;(def sects-cl \n  (let [sects (let [s (partition n1 entries)] (for [s1 s, s2 s] (for [r s1 l s2] [r l])))\n        syms (for [sect sects v entries] (map #(make-sym (conj % v)) sect))]\n    (mapcat #(max-kof 1 %) syms)))&quot; &quot;sects-cl&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch ))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch ))\n            (= 0 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (into () ((apply vector filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr))))))&quot; &quot;(defn bench1\n  []\n  (let [puzzles (parse \&quot;resources/sudoku/easy50.txt\&quot;)]\n    (map solve puzzles)))&quot; &quot;(defn bench1\n  []\n  (let [puzzles (parse \&quot;resources/sudoku/easy50.txt\&quot;)]\n    (map solve puzzles)\n    :done))&quot; &quot;(time\n  (doall (bench1)))&quot; &quot;(time\n  (let [puzzles (parse \&quot;resources/sudoku/easy50.txt\&quot;)]\n    (dorun (map solve puzzles))\n    :done))&quot; &quot;(def easy50 \&quot;resources/sudoku/easy50.txt\&quot;)&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (into () (apply vector (filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr))))))&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (apply vector (filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr)))))&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr))))&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (list (filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr)))))&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (into () (filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr)))))&quot; &quot;(defn bench\n [puzzles]\n (time\n  (dorun (map solve puzzles)\n  :done)))&quot; &quot;(defn bench\n [puzzles]\n (time\n  (dorun (map solve puzzles))\n  :done))&quot; &quot;(def n1\n  \&quot;Order of the grid\&quot;\n  4)&quot; &quot;(def n1\n  \&quot;Order of the grid\&quot;\n  5)&quot; &quot;entries&quot; &quot;(def n1\n  \&quot;Order of the grid\&quot;\n  3)&quot; &quot;(def n2\n  \&quot;Size of the units\&quot;\n  (* n1 n1))&quot; &quot;(def n4\n  \&quot;Number of cells\&quot;\n  (* n2 n2))&quot; &quot;(def entries\n  \&quot;Entries for cells\&quot;\n  (map #(char (+ (int \\0) %)) (range 1 (inc n2))))&quot; &quot;(defn- make-sym \n  \&quot;Makes a symbol from [row, col, value].\&quot;\n  [[row col value]]\n  (symbol (str \&quot;c\&quot; row col value)))&quot; &quot;(def cell-cl\n  (let [cell-syms (partition n2 (for [r entries, c entries, v entries]\n                 (make-sym [r c v])))]\n    (mapcat oneof cell-syms)))&quot; &quot;cell-cl&quot; &quot;cols-cl&quot; &quot;(def boxes-cl\n  (let [sects (let [s (partition n1 entries)] (for [s1 s, s2 s] (for [r s1 l s2] [r l])))\n        syms (for [sect sects v entries] (map #(make-sym (conj % v)) sect))]\n    (mapcat #(max-kof 1 %) syms)))&quot; &quot;boxes-cl&quot; &quot;(def rules-cl (concat cell-cl rows-cl cols-cl boxes-cl))&quot; &quot;(count rules-cl)&quot; &quot;(defn puzzle-cl\n  \&quot;Clauses for the puzzle.\&quot;\n  [puzzle]\n  (let [make-vec (fn [idx ch] (if (= ch \\.) \n                                  nil \n                                  [(inc (quot idx n2)) (inc (rem idx n2)) (- (int ch) (int \\0))]))\n        make-cl  (fn [vec] (list 'or (make-sym vec))) ]\n    (map make-cl (filter #(not (nil? %)) (map-indexed make-vec puzzle)))))&quot; &quot;(defn sudoku-prop\n  [puzzle]\n  (apply list 'and (concat (puzzle-cl  puzzle) rules-cl)))&quot; &quot;(sudoku-prop puzzle)&quot; &quot;(defn true-only\n  \&quot;Sequence of true atoms in an assignment vector\&quot;\n  [assign-vec]\n  (loop [vec assign-vec, result []]\n    (if (empty? vec)\n      result\n      (let [atom (first vec) value (second vec)]\n        (recur (subvec vec 2) (if value (conj result atom) result))))))&quot; &quot;(defn true-vec2solution\n  \&quot;Solution from vector of true atoms\&quot;\n  [true-vec]\n  (let [vec (sort true-vec)]\n    (mapv #(nth (name %) 3) vec)))&quot; &quot;(defn pretty-print\n  \&quot;Ptretty-printing Sudoku of order 3.\&quot;\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (if (= 1 (mod col n1))\n        (print (str \&quot;| \&quot; ch ))\n        (print (str \&quot; \&quot; ch )))\n      (if (= 9 col) (print \&quot; |\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  \&quot;Ptretty-printing Sudoku of order 3.\&quot;\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (if (= 1 (mod col n1))\n        (print (str \&quot;| \&quot; ch \&quot; \&quot;))\n        (print (str ch \&quot; \&quot;)))\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  \&quot;Ptretty-printing Sudoku of order 3.\&quot;\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (if (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch \&quot; \&quot;)) (print (str ch \&quot; \&quot;)))\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;hardest&quot; &quot;(count hardest)&quot; &quot;easy50&quot; &quot;(bench hardest)&quot; &quot;(bench top95)&quot; &quot;&quot; &quot;top95&quot; &quot;(ns lwb.prop.examples.sudoku\n  (:require [clojure.java.io :refer (reader)])\n  (:require [lwb.prop.cardinality :refer (oneof max-kof min-kof)])\n  (:require [lwb.prop.sat :refer (sat)])\n)&quot; &quot;(def puzzle (apply vector \&quot;.24...38.6.72.91.481.7.3.96.48...97...........69...51.75.9.8.414.16.57.9.96...83.\&quot;))&quot; &quot;(solve puzzle)&quot; &quot;(defn solve\n  \&quot;Solve Sudoku puzzle\&quot;\n  [puzzle]\n  #_(sat (sudoku-prop puzzle))\n  (-&gt;&gt; puzzle\n       (sudoku-prop)\n       (sat)\n       (true-only)\n       (true-vec2solution)))&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (into () (map vec (filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr))))))&quot; &quot;(defn bench\n [puzzles]\n (time\n  (do\n    (dorun (map solve puzzles))\n    :done)))&quot; &quot;(def easy50 (parse \&quot;resources/sudoku/easy50.txt\&quot;))&quot; &quot;(bench easy50)&quot; &quot;(dotimes [_ 10]\n  (bench easy50))&quot; &quot;(def top95 (parse \&quot;resources/sudoku/top95.txt\&quot;))&quot; &quot;(dotimes [_ 10]\n  (bench top95))&quot; &quot;(def hardest (parse \&quot;resources/sudoku/hardest.txt\&quot;))&quot; &quot;(dotimes [_ 10]\n  (bench hardest))&quot; &quot;rows-cl&quot; &quot;(defn rows\n  \&quot;Matrix of the chars in the rows.\&quot;\n  [puzzle]\n  (mapv vec (partition n2 puzzle)))&quot; &quot;(def rows-cl\n  (let  [syms (for [row rows v entries] (map #(make-sym (conj % v)) row ))]\n    (mapcat #(max-kof 1 %) syms)))&quot; &quot;(def cols-cl\n  (let [cols (partition n2 (for [r entries c entries] [c r]))\n        syms (for [col cols v entries] (map #(make-sym (conj % v)) col ))]\n    (mapcat #(max-kof 1 %) syms)))&quot; &quot;(def blk-cl\n  (let [blks (let [s (partition n1 entries)] (for [s1 s, s2 s] (for [r s1 l s2] [r l])))\n        syms (for [blk blks v entries] (map #(make-sym (conj % v)) blk))]\n    (mapcat #(max-kof 1 %) syms)))&quot; &quot;(def rows-cl\n  (let [rows (partition n2 (for [r entries c entries] [r c]))\n        syms (for [row rows v entries] (map #(make-sym (conj % v)) row ))]\n    (mapcat #(max-kof 1 %) syms)))&quot; &quot;(def rules-cl (concat cell-cl rows-cl cols-cl blk-cl))&quot; &quot;(defn puzzle-cl\n  \&quot;Clauses for the givens of the puzzle.\&quot;\n  [puzzle]\n  (let [make-vec (fn [idx ch] (if (= ch \\.) \n                                  nil \n                                  [(inc (quot idx n2)) (inc (rem idx n2)) (- (int ch) (int \\0))]))\n        make-cl  (fn [vec] (list 'or (make-sym vec))) ]\n    (map make-cl (filter #(not (nil? %)) (map-indexed make-vec puzzle)))))&quot; &quot;(defn sudoku-prop\n  [puzzle]\n  (apply list 'and (concat (puzzle-cl puzzle) rules-cl)))&quot; &quot;(defn solve\n  \&quot;Solve Sudoku puzzle\&quot;\n  [puzzle]\n  (-&gt; puzzle\n       (sudoku-prop)\n       (sat)\n       (solution)))&quot; &quot;rules-cl&quot; &quot;(def puzzle (vec \&quot;.24...38.6.72.91.481.7.3.96.48...97...........69...51.75.9.8.414.16.57.9.96...83.\&quot;))&quot; &quot;puzzle&quot; &quot;(pretty-print puzzle)&quot; &quot;(pretty-print (solve puzzle))&quot;], :remote []}}</component>
</project>
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1417430253634">{:repl-history {:ide [], :local [&quot;(apply clojure.string/join \&quot;|\&quot; (partition n1 line))&quot; &quot;(clojure.string/join \&quot;|\&quot; (partition n1 line))&quot; &quot;(clojure.string/join \&quot;|\&quot; (map #(apply str %) (partition n1 line)))&quot; &quot;(clojure.string/join \&quot;|\&quot; (map #(apply str (nterpose \&quot; \&quot; %)) (partition n1 line)))&quot; &quot;(clojure.string/join \&quot;|\&quot; (map #(apply str (interpose \&quot; \&quot; %)) (partition n1 line)))&quot; &quot;(str \&quot;|\&quot; (clojure.string/join \&quot;|\&quot; (map #(apply str (interpose \&quot; \&quot; %)) (partition n1 line))))&quot; &quot;(str \&quot;|\&quot; (clojure.string/join \&quot;|\&quot; (map #(apply str (interpose \&quot; \&quot; %)) (partition n1 line))) \&quot;|\&quot;)&quot; &quot;(defn- pp-line\n  [line]\n  (str \&quot;|\&quot; (clojure.string/join \&quot;|\&quot; (map #(apply str (interpose \&quot; \&quot; %)) (partition n1 line))) \&quot;|\&quot;)\n  )&quot; &quot;(defn pretty-print\n  \&quot;Pretty print a Sudoku puzzle or solution\&quot;\n  [puzzle]\n  (let [rule \&quot;+-----+----+-----+\&quot;\n        lines (partition n2 puzzle)]\n    (for [line lines]\n      (pp-line line))\n\n    )\n\n  )&quot; &quot;(defn pretty-print\n  \&quot;Pretty print a Sudoku puzzle or solution\&quot;\n  [puzzle]\n  (let [rule \&quot;+-----+----+-----+\&quot;\n        lines (partition n2 puzzle)]\n    (clojure.string/join \&quot;n\&quot; lines)\n    )\n  )&quot; &quot;(defn pretty-print\n  \&quot;Pretty print a Sudoku puzzle or solution\&quot;\n  [puzzle]\n  (let [rule \&quot;+-----+----+-----+\&quot;\n        lines (partition n2 puzzle)]\n    (clojure.string/join \&quot;\\n\&quot; (pp-line lines))\n    )\n  )&quot; &quot;(defn pretty-print\n  \&quot;Pretty print a Sudoku puzzle or solution\&quot;\n  [puzzle]\n  (let [rule \&quot;+-----+----+-----+\&quot;\n        lines (partition n2 puzzle)]\n    (clojure.string/join \&quot;\\n\&quot; (map pp-line lines))\n    )\n  )&quot; &quot;(defn pretty-print\n  \&quot;Pretty print a Sudoku puzzle or solution\&quot;\n  [puzzle]\n  (let [rule \&quot;+-----+----+-----+\&quot;\n        lines (partition n2 puzzle)]\n    (print (clojure.string/join \&quot;\\n\&quot; (map pp-line lines)))\n    )\n  )&quot; &quot;(defn pretty-print\n  \&quot;Pretty print a Sudoku puzzle or solution\&quot;\n  [puzzle]\n  (let [rule \&quot;+-----+----+-----+\\n\&quot;\n        lines (partition n2 puzzle)]\n    (print (clojure.string/join (str \&quot;\\n\&quot; rule) (map pp-line lines)))\n    )\n  )&quot; &quot;(defn pretty-print\n  \&quot;Pretty print a Sudoku puzzle or solution\&quot;\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;\n        lines (partition n2 puzzle)]\n    (print (clojure.string/join (str \&quot;\\n\&quot; rule) (map pp-line lines)))\n    )\n  )&quot; &quot;(map-indexed identity demopuzzle)&quot; &quot;(map-indexed #(identity %) demopuzzle)&quot; &quot;(map-indexed #(identity %) ( seq demopuzzle))&quot; &quot;demopuzzle&quot; &quot;(seq demopuzzle)&quot; &quot;(map identity demopuzzle)&quot; &quot;(map-indexed #([%1 %2]) demopuzzle)&quot; &quot;(map-indexed #(vector %1 %2) demopuzzle)&quot; &quot;(defn pretty-print\n  [puzzle]\n  (doseq [cell (map-indexed #(vector %1 %2) puzzle)]\n    print cell))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (doseq [cell (map-indexed #(vector %1 %2) puzzle)]\n    (print cell)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (doseq [cell (map-indexed #(vector %1 %2) puzzle)]\n     (print cell))))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (doseq [cell (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      ; berechne row and col und verfahre entsprechend\n     (print cell))))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      ; berechne row and col und verfahre entsprechend\n     (print [row col ch]))))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      ; berechne row and col und verfahre entsprechend\n      (print rule)\n      (print [row col ch ])\n      (print rule))))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (print rule)\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      ; berechne row and col und verfahre entsprechend\n      (print [row col ch ]))\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (print rule)\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      ; berechne row and col und verfahre entsprechend\n      (print [row col ch])\n      (if (= 9 col) (print \&quot;\\n\&quot;)))\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (print rule)\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      ; berechne row and col und verfahre entsprechend\n      (cond (= 1 (mod col n1))\n            (print (str \&quot;|\&quot; ch)))\n      (print [row col ch])\n      (if (= 9 col) (print \&quot;\\n\&quot;)))\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (print rule)\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      ; berechne row and col und verfahre entsprechend\n      (cond (= 1 (mod col n1)) (print (str \&quot;|\&quot; ch))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print (str ch \&quot;|\&quot;))\n            )\n      (if (= 9 col) (print \&quot;\\n\&quot;)))\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (print rule)\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      ; berechne row and col und verfahre entsprechend\n      (cond (= 1 (mod col n1)) (print (str \&quot;|\&quot; ch))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;)))\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (print rule)\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      ; berechne row and col und verfahre entsprechend\n      (cond (= 1 (mod col n1)) (print (str \&quot;|\&quot; ch))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-----+-----+-----+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;|\&quot; ch))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(sat? '(and p q))&quot; &quot;(sat? '(and p (not q)))&quot; &quot;(defn valid?\n  \&quot;Is `phi`valid?\&quot;\n  [phi]\n  (sat? '(not phi)))&quot; &quot;(defn valid?\n  \&quot;Is `phi` valid?\&quot;\n  [phi]\n  (not (sat? '(not phi))))&quot; &quot;(def phi '(or p (not p)))&quot; &quot;(tt phi)&quot; &quot;(print-truth-table phi)&quot; &quot;(print-truth-table (truth-table phi))&quot; &quot;(truth-table phi)&quot; &quot;(sat phi :all)&quot; &quot;(sat? phi)&quot; &quot;(defn valid?\n  \&quot;Is `phi` valid?\&quot;\n  [phi]\n  (sat? '(not phi)))&quot; &quot;(sat? '(not phi))&quot; &quot;(sat '(not phi))&quot; &quot;(sat (list not phi))&quot; &quot;(sat? (list not phi))&quot; &quot;(valid? '(and p (not p)))&quot; &quot;(defn print-table\n  \&quot;Pretty prints vector `header` and vector of vectors `table`.   \n   Pre: header and row in the table have the same no of item,\n        the size of items in header is &gt;= size of items in the rows.\&quot;\n  ; inspired from clojure.pprint\n  [header table]\n  (let [table'  (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table)) \n        widths  (map #(count (str %)) header)\n        spacers (map #(apply str (repeat % \&quot;-\&quot;)) widths)\n        fmts    (map #(str \&quot;%\&quot; % \&quot;s\&quot;) widths)\n        fmt-row (fn [leader divider trailer row]\n                  (str leader\n                     (apply str (interpose divider\n                        (for [[col fmt] (map vector row fmts)]\n                              (format fmt (str col)))))\n                       trailer))]\n    (println)\n    (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; header))\n    (println (fmt-row \&quot;|-\&quot; \&quot;-+-\&quot; \&quot;-|\&quot; spacers))\n    (doseq [row table']\n      (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; row))))\n\n(defn print-truth-table \n  \&quot;Pretty prints truth-table.\&quot;\n  [{:keys [formula header table]}]\n  (let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    (println \&quot;Truth table\&quot;)\n    (println formula)\n\t  (print-table header table'))))&quot; &quot;(print-truth-table (truth-table '(or p q)))&quot; &quot;(truth-table '(or p q))&quot; &quot;(defn print-table\n  \&quot;Pretty prints vector `header` and vector of vectors `table`.   \n   Pre: header and row in the table have the same no of item,\n        the size of items in header is &gt;= size of items in the rows.\&quot;\n  ; inspired from clojure.pprint\n  [header table]\n  (let [table'  (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table)) \n        widths  (map #(count (str %)) header)\n        spacers (map #(apply str (repeat % \&quot;-\&quot;)) widths)\n        fmts    (map #(str \&quot;%\&quot; % \&quot;s\&quot;) widths)\n        fmt-row (fn [leader divider trailer row]\n                  (str leader\n                     (apply str (interpose divider\n                        (for [[col fmt] (map vector row fmts)]\n                              (format fmt (str col)))))\n                       trailer))]\n    (println)\n    (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; header))\n    (println (fmt-row \&quot;|-\&quot; \&quot;-+-\&quot; \&quot;-|\&quot; spacers))\n    (doseq [row table']\n      (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; row))))\n\n(defn print-truth-table \n  \&quot;Pretty prints truth-table.\&quot;\n  [{:keys [formula header table]}]\n  (let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    (println \&quot;Truth table\&quot;)\n    (println (list formula))\n\t  (print-table header table'))))&quot; &quot;(defn print-table\n  \&quot;Pretty prints vector `header` and vector of vectors `table`.   \n   Pre: header and row in the table have the same no of item,\n        the size of items in header is &gt;= size of items in the rows.\&quot;\n  ; inspired from clojure.pprint\n  [header table]\n  (let [table'  (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table)) \n        widths  (map #(count (str %)) header)\n        spacers (map #(apply str (repeat % \&quot;-\&quot;)) widths)\n        fmts    (map #(str \&quot;%\&quot; % \&quot;s\&quot;) widths)\n        fmt-row (fn [leader divider trailer row]\n                  (str leader\n                     (apply str (interpose divider\n                        (for [[col fmt] (map vector row fmts)]\n                              (format fmt (str col)))))\n                       trailer))]\n    (println)\n    (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; header))\n    (println (fmt-row \&quot;|-\&quot; \&quot;-+-\&quot; \&quot;-|\&quot; spacers))\n    (doseq [row table']\n      (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; row))))\n\n(defn print-truth-table \n  \&quot;Pretty prints truth-table.\&quot;\n  [{:keys [formula header table]}]\n  (let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    (println \&quot;Truth table\&quot;)\n    ;(println formula)\n\t  (print-table header table'))))&quot; &quot;(defn print-table\n  \&quot;Pretty prints vector `header` and vector of vectors `table`.   \n   Pre: header and row in the table have the same no of item,\n        the size of items in header is &gt;= size of items in the rows.\&quot;\n  ; inspired from clojure.pprint\n  [header table]\n  (let [table'  (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table)) \n        widths  (map #(count (str %)) header)\n        spacers (map #(apply str (repeat % \&quot;-\&quot;)) widths)\n        fmts    (map #(str \&quot;%\&quot; % \&quot;s\&quot;) widths)\n        fmt-row (fn [leader divider trailer row]\n                  (str leader\n                     (apply str (interpose divider\n                        (for [[col fmt] (map vector row fmts)]\n                              (format fmt (str col)))))\n                       trailer))]\n    (println)\n    (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; header))\n    (println (fmt-row \&quot;|-\&quot; \&quot;-+-\&quot; \&quot;-|\&quot; spacers))\n    (doseq [row table']\n      (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; row))))\n\n(defn print-truth-table \n  \&quot;Pretty prints truth-table.\&quot;\n  [{:keys [formula header table]}]\n  (let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    ;(println \&quot;Truth table\&quot;)\n    ;(println formula)\n\t  (print-table header table'))))&quot; &quot;(defn print-table\n  \&quot;Pretty prints vector `header` and vector of vectors `table`.   \n   Pre: header and row in the table have the same no of item,\n        the size of items in header is &gt;= size of items in the rows.\&quot;\n  ; inspired from clojure.pprint\n  [header table]\n  (let [table'  (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table)) \n        widths  (map #(count (str %)) header)\n        spacers (map #(apply str (repeat % \&quot;-\&quot;)) widths)\n        fmts    (map #(str \&quot;%\&quot; % \&quot;s\&quot;) widths)\n        fmt-row (fn [leader divider trailer row]\n                  (str leader\n                     (apply str (interpose divider\n                        (for [[col fmt] (map vector row fmts)]\n                              (format fmt (str col)))))\n                       trailer))]\n    (println)\n    (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; header))\n    (println (fmt-row \&quot;|-\&quot; \&quot;-+-\&quot; \&quot;-|\&quot; spacers))\n    (doseq [row table']\n      (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; row))))\n\n(defn print-truth-table \n  \&quot;Pretty prints truth-table.\&quot;\n  [{:keys [formula header table]}]\n  (\n  ;(let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    ;(println \&quot;Truth table\&quot;)\n    ;(println formula)\n\t  (print-table header table))))&quot; &quot;(:header tt)&quot; &quot;(defn print-table\n  \&quot;Pretty prints vector `header` and vector of vectors `table`.   \n   Pre: header and row in the table have the same no of item,\n        the size of items in header is &gt;= size of items in the rows.\&quot;\n  ; inspired from clojure.pprint\n  [header table]\n  (let [table'  (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table)) \n        widths  (map #(count (str %)) header)\n        spacers (map #(apply str (repeat % \&quot;-\&quot;)) widths)\n        fmts    (map #(str \&quot;%\&quot; % \&quot;s\&quot;) widths)\n        fmt-row (fn [leader divider trailer row]\n                  (str leader\n                     (apply str (interpose divider\n                        (for [[col fmt] (map vector row fmts)]\n                              (format fmt (str col)))))\n                       trailer))]\n    (println)\n    (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; header))\n    (println (fmt-row \&quot;|-\&quot; \&quot;-+-\&quot; \&quot;-|\&quot; spacers))\n    (doseq [row table']\n      (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; row))))\n\n(defn print-truth-table \n  \&quot;Pretty prints truth-table.\&quot;\n  [{:keys [formula header table]}]\n  (\n    [formula header table]\n  ;(let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    ;(println \&quot;Truth table\&quot;)\n    ;(println formula)\n\t  #_(print-table header table))))&quot; &quot;(:formula tt)&quot; &quot;(defn print-table\n  \&quot;Pretty prints vector `header` and vector of vectors `table`.   \n   Pre: header and row in the table have the same no of item,\n        the size of items in header is &gt;= size of items in the rows.\&quot;\n  ; inspired from clojure.pprint\n  [header table]\n  (let [table'  (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table)) \n        widths  (map #(count (str %)) header)\n        spacers (map #(apply str (repeat % \&quot;-\&quot;)) widths)\n        fmts    (map #(str \&quot;%\&quot; % \&quot;s\&quot;) widths)\n        fmt-row (fn [leader divider trailer row]\n                  (str leader\n                     (apply str (interpose divider\n                        (for [[col fmt] (map vector row fmts)]\n                              (format fmt (str col)))))\n                       trailer))]\n    (println)\n    (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; header))\n    (println (fmt-row \&quot;|-\&quot; \&quot;-+-\&quot; \&quot;-|\&quot; spacers))\n    (doseq [row table']\n      (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; row))))\n\n(defn print-tt \n  \&quot;Pretty prints truth-table.\&quot;\n  [{:keys [formula header table]}]\n  (\n    [formula header table]\n  ;(let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    ;(println \&quot;Truth table\&quot;)\n    ;(println formula)\n\t  #_(print-table header table))))&quot; &quot;(print-truth-table tt)&quot; &quot;(defn truth-table\n  \&quot;Truth table of `phi`.   \n   If `mode` is `:true-only` the table contains only the valuations where\n   `phi` evaluates to `true`.   \n   For `mode` of `:false-only` accordingly.\&quot;\n  ([phi]\n  (let [atoms (atoms-of-phi phi)]\n    (if (&gt; (count atoms) 10)\n      (throw (IllegalArgumentException. \n               (str \&quot;This formula has more than 10 variables.\&quot; \n                    \\newline \n                    \&quot;The truth table would consist of more than 1024 rows,\&quot; \n                    \&quot;so you might want to use the SAT solver.\&quot;)))\n\t    \n\t    (let [all-combs (selections [true false] (count atoms))\n\t          assign-vecs (for [comb all-combs] (vec (interleave atoms comb)))]\n         {:formula phi\n          :header  (conj (vec atoms) :result)\n\t        :table   (vec (for [assign-vec assign-vecs]\n                          (conj (vec (take-nth 2 (rest assign-vec)))\n                                (eval-phi phi assign-vec))))}))))\n  ([phi mode]\n    (let [tt (truth-table phi)]\n    (condp = mode\n      :true-only (assoc tt :table (vec (filter #(true? (last %)) (:table tt))))\n      :false-only (assoc tt :table (vec (filter #(false? (last %)) (:table tt))))\n      tt))))&quot; &quot;(defn print-table\n  \&quot;Pretty prints vector `header` and vector of vectors `table`.   \n   Pre: header and row in the table have the same no of item,\n        the size of items in header is &gt;= size of items in the rows.\&quot;\n  ; inspired from clojure.pprint\n  [header table]\n  (let [table'  (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table)) \n        widths  (map #(count (str %)) header)\n        spacers (map #(apply str (repeat % \&quot;-\&quot;)) widths)\n        fmts    (map #(str \&quot;%\&quot; % \&quot;s\&quot;) widths)\n        fmt-row (fn [leader divider trailer row]\n                  (str leader\n                     (apply str (interpose divider\n                        (for [[col fmt] (map vector row fmts)]\n                              (format fmt (str col)))))\n                       trailer))]\n    (println)\n    (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; header))\n    (println (fmt-row \&quot;|-\&quot; \&quot;-+-\&quot; \&quot;-|\&quot; spacers))\n    (doseq [row table']\n      (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; row))))\n\n(defn print-tt\n  \&quot;Pretty prints truth-table.\&quot;\n  [{ :keys [formula header table]}]\n  (\n    [formula header table]\n  ;(let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    ;(println \&quot;Truth table\&quot;)\n    ;(println formula)\n\t  #_(print-table header table))))&quot; &quot;(:keys tt)&quot; &quot;(:table tt)&quot; &quot;(defn print-table\n  \&quot;Pretty prints vector `header` and vector of vectors `table`.   \n   Pre: header and row in the table have the same no of item,\n        the size of items in header is &gt;= size of items in the rows.\&quot;\n  ; inspired from clojure.pprint\n  [header table]\n  (let [table'  (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table)) \n        widths  (map #(count (str %)) header)\n        spacers (map #(apply str (repeat % \&quot;-\&quot;)) widths)\n        fmts    (map #(str \&quot;%\&quot; % \&quot;s\&quot;) widths)\n        fmt-row (fn [leader divider trailer row]\n                  (str leader\n                     (apply str (interpose divider\n                        (for [[col fmt] (map vector row fmts)]\n                              (format fmt (str col)))))\n                       trailer))]\n    (println)\n    (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; header))\n    (println (fmt-row \&quot;|-\&quot; \&quot;-+-\&quot; \&quot;-|\&quot; spacers))\n    (doseq [row table']\n      (println (fmt-row \&quot;| \&quot; \&quot; | \&quot; \&quot; |\&quot; row)))))&quot; &quot;(defn print-tt\n  \&quot;Pretty prints truth-table.\&quot;\n  [{ :keys [formula header table]}]\n  (\n    [formula header table]\n  ;(let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    ;(println \&quot;Truth table\&quot;)\n    ;(println formula)\n\t  #_(print-table header table)))&quot; &quot;(defn print-tt\n  \&quot;Pretty prints truth-table.\&quot;\n  [{:keys [formula header table]}]\n  (\n    [formula header table]\n  ;(let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    ;(println \&quot;Truth table\&quot;)\n    ;(println formula)\n\t  #_(print-table header table)))&quot; &quot;(def tt (truth-table '(or p q)))&quot; &quot;(let [{:keys [formula header table]} tt]\n  [formula header table])&quot; &quot;(defn print-tt\n  \&quot;Pretty prints truth-table.\&quot;\n  [{:keys [formula header table]}]\n    [formula header table]\n  ;(let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    ;(println \&quot;Truth table\&quot;)\n    ;(println formula)\n\t  #_(print-table header table))&quot; &quot;(defn print-tt\n  \&quot;Pretty prints truth-table.\&quot;\n  [{:keys [formula header table]}]\n    [formula header table]\n  (let [table' (vec (map #(replace {true \&quot;T\&quot; false \&quot;F\&quot;} %) table))]\n    (println \&quot;Truth table\&quot;)\n    (println formula)\n\t  (print-table header table)))&quot; &quot;(print-tt tt)&quot; &quot;(defn valid?\n  \&quot;Is `phi` valid?\&quot;\n  [phi]\n  (sat? (list not phi)))&quot; &quot;(defn sat?\n  \&quot;Is `phi` satisfiable?\&quot;\n  [phi]\n  (if (nil? (sat phi)) false true))&quot; &quot;(list not p)&quot; &quot;(list not 'p)&quot; &quot;(sat? 'p)&quot; &quot;(sat? '(or p q))&quot; &quot;(defn valid?\n  \&quot;Is `phi` valid?\&quot;\n  [phi]\n  (not (sat? (list 'not phi))))&quot; &quot;(valid? 'p)&quot; &quot;(valid? '(and p q))&quot; &quot;(valid? '(or p (not p)))&quot; &quot;(sat? '(not (or p (not p))))&quot; &quot;(sat? '(and p (not p)))&quot; &quot;(valid? '(not (and p (not p))))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch \&quot; \&quot;))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch \&quot;\&quot;))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch \&quot; \&quot;)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch ))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch ))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            (= 0 (mod col n1)) (print ch \&quot; \&quot;)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch ))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch ))\n            (= 0 (mod col n1)) (print ch \&quot; \&quot;)\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (cond (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch ))\n            (= 2 (mod col n1)) (print (str \&quot; \&quot; ch ))\n            (= 0 (mod col n1)) (print (str \&quot; \&quot; ch \&quot; \&quot;))\n            )\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(pretty-print demopuzzle)&quot; &quot;(pretty-print (solve demopuzzle))&quot; &quot;(parse \&quot;resources/sudoku/easy50.txt\&quot;)&quot; &quot;(defn bench1\n  []\n  (let [puzzles (parse \&quot;resources/sudoku/easy50.txt\&quot;)]\n    (map solve puzzles)))&quot; &quot;bench1&quot;], :remote []}}</component>
</project>